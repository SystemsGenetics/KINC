const char* __/__/KINC/src/pearson_cl =
"// http://www.stat.wmich.edu/s216/book/node122.html\n"
"\n"
"// Precondition: File data will have to be read in\n"
"// done timestamp: 4:00 pm 11-22-1016\n"
"\n"
"\n"
"\n"
"/********************************DATA PARTITIONING*****************************/\n"
"// Initially we'll need dummy data (2 - 80 double entries)\n"
"/*****************************END DATA PARTITIONING****************************/\n"
"\n"
"\n"
"\n"
"/*****************************PROCESS PARTITIONING*****************************/\n"
"// The processing block listed below will be 'placed' in here\n"
"// this part bridges with the data partitioning labeled above\n"
"/*****************************END PROCESS PARTITIONING*************************/\n"
"\n"
"\n"
"\n"
"/*********************************PROCESSING**********************************/\n"
"\n"
"/******************************PSEUDO CODE************************************/\n"
"\n"
"/* Human readable Steps to get the Coefficient */\n"
"/*\n"
"   1. Multiply the current row to subsequent rows beneath it\n"
"    a. Add the the products from multiplying two rows into one sum\n"
"       This will be variable A (Sum of multiplying 2 rows)\n"
"   2. Sum the the current row and the row beneath the current seperately\n"
"    a. This will be variable B (sum of entries in current row) and C (sum of\n"
"       entries in lower row)\n"
"    b. Multiply B and C to get variable D\n"
"    c. Divide D by E (the integral number of entries (this should be the same\n"
"       for every row))\n"
"    d. Call the result of this F\n"
"   3. Subtract: 1. - 2. (or A - F) This gives the covariance of the two\n"
"      particular samples. We will call this end result G.\n"
"    a. If there is a number there that is not 'too close' to 0, then the two\n"
"       genes/transcripts may have some sort of relationship in their respective\n"
"       synthesis/construction/expression\n"
"   4. Square and add each entry of the respective row and the subsequent row as\n"
"      well\n"
"    a. Respectively these variables will be called H and I\n"
"  5. Sum each row and square the sum of the respective row and the subsequent\n"
"     row as well\n"
"    a. Respectively these variables will be called J and K\n"
"  6. Divide 5. (J and K) by E (the integral number of entries of the specific\n"
"     row (this number should be the same for EVERY row))\n"
"    a. Call the results of J/E and K/E: L and M respectively\n"
"  7. Subtract H by L (H - L) and I by M (I - M)\n"
"    a. Call the results N and O respectively\n"
"  8. Multiply N and O and take the square root of the product\n"
"    a. Call the result P\n"
"  9. Divide F by P (F / P)\n"
"    a. Call this the result the Pearson Coefficient\n"
"    b. OH SNAP! We're done\n"
"*/\n"
"\n"
"// Possible # of Intermediate Variables: 16 intermediate variables\n"
"\n"
"/*****************************CL FUNCTION CALLS*******************************/\n"
"\n"
"/* Toes into OpenCL */\n"
"/* Precondition: Have two different rows in scope of this kernel */\n"
"/*\n"
"  Update: This pseudo code is using vectors, but in the actual implementation\n"
"          the code is using Josh Burns' indexed based access of the data\n"
"*/\n"
"\n"
"/*\n"
"  Functions that can used in acquiring the above variables\n"
"  Variable A: Use the dot product\n"
"    The largest vector using the 1.2 standard is the 16 wide vector\n"
"    16*5 = 80. Split the row into 5 sets of 'dotting' double16 vectors add the\n"
"    5 sepearate scalars together.\n"
"    ***(SEPEARATE FUNCTION)\n"
"  Variable B and C: Sum the rows (5 sets of double16 vectors) into scalars\n"
"    ***(SEPEARATE FUNCTION)\n"
"  Variable D: Scalar multiplication B * C store in D\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable E: This should be the number 80 (the sSize!)\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable F: Scalar division D / E store in F\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable G: Scalar subtraction A - F store in G\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable H and I: Square atomically (each of the elements in the vectors) the\n"
"    5 double16 vectors add their respective squares together.\n"
"    ***(SEPEARATE FUNCTION)\n"
"  Variable J and K: Square scalars B and C and store in variables (J & K)\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable L and M: Scalar Division (L = J / E) and (M = K / E)\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable N and O: Scalar subtraction (N = H - L) & (O = I - M)\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"  Variable P: Scalar multiplication and root (sqrt(N*O))\n"
"    ***(IN PEARSON MAIN FUNCTION)\n"
"\n"
"  Variable FIN: Scalar Division (F / P)\n"
"\n"
"*/\n"
"\n"
"/*******************************END PROCESSING********************************/\n"
"\n"
"\n"
"/*\n"
"  The data prep code simply extracts two of the rows from the 1-D list that was\n"
"  passed to a given kernel\n"
"  TODO: Ask Josh for clarification on how the offsetting works EXACTLY\n"
"*/\n"
"/*******************************BEGIN DATA PREP*******************************/\n"
"/*\n"
"  Plagerized code from Josh Burns' spearman cl code\n"
"  Fetch the expression scores from two rows (these are the two rows to compare)\n"
"*/\n"
"\n"
"void fetch_lists(int aInd, int bInd, int size, int chunk, __global float* aList,\n"
"                 __global float* bList, __global float* exprs)\n"
"{\n"
"   int i,c,ix;\n"
"   for (i=0;i<chunk;++i)\n"
"   {\n"
"     // Why 2? for the max? for the 'row'?\n"
"     // row 0 and row 1?\n"
"     //\n"
"      for (c=0;c<2;++c)\n"
"      {\n"
"         ix = (get_local_id(0)*chunk+i)*2+c;\n"
"         if (ix<size)\n"
"         {\n"
"            if (isnan(exprs[aInd+ix]) || isnan(exprs[bInd+ix]))\n"
"            {\n"
"               aList[ix] = INFINITY;\n"
"               bList[ix] = INFINITY;\n"
"            }\n"
"            else\n"
"            {\n"
"               aList[ix] = exprs[aInd+ix];\n"
"               bList[ix] = exprs[bInd+ix];\n"
"            }\n"
"         }\n"
"         else\n"
"         {\n"
"            aList[ix] = INFINITY;\n"
"            bList[ix] = INFINITY;\n"
"         }\n"
"      }\n"
"   }\n"
"   barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"\n"
"/*\n"
"  Plagerized code from Joshi Burns' Spearman ACE plugin implementation\n"
"  Another piece of prepping the data (from NAN's)\n"
"*/\n"
"void prune_lists(int chunk, __global float* aExprs, __global int* aWork, __global int* aPoint,\n"
"                 __global float* bExprs, __global int* bWork, __global int* bPoint)\n"
"{\n"
"   int i,c,ix;\n"
"   for (i=0;i<chunk;++i)\n"
"   {\n"
"      for (c=0;c<2;++c)\n"
"      {\n"
"         ix = (get_local_id(0)*chunk+i)*2+c;\n"
"         aPoint[ix] = ix;\n"
"         bPoint[ix] = ix;\n"
"         if (isinf(aExprs[ix]))\n"
"         {\n"
"            aWork[ix] = get_local_size(0)*4;\n"
"         }\n"
"         else\n"
"         {\n"
"            aWork[ix] = ix;\n"
"         }\n"
"         if (isinf(bExprs[ix]))\n"
"         {\n"
"            bWork[ix] = get_local_size(0)*4;\n"
"         }\n"
"         else\n"
"         {\n"
"            bWork[ix] = ix;\n"
"         }\n"
"      }\n"
"   }\n"
"   barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"/*******************************END DATA PREP*********************************/\n"
"\n"
"\n"
"/*****************************BEGIN DOT ROWS**********************************/\n"
"/*\n"
"  To be used in the construction of variable A\n"
"  var dot_product will be passed in initialized to 0\n"
"*/\n"
"void dot_rows(int chunk,  __global float* aList,  __global float* bList,\n"
"             __global float* dot_product)\n"
"{\n"
"  int i,c,ix;\n"
"   // Plagerized from Josh Burns' codebase\n"
"   // These two for loops are the basic way of accessing the two 'rows'\n"
"   for (i=0;i<chunk;++i)\n"
"   {\n"
"      for (c=0;c<2;++c)\n"
"      {\n"
"         ix = (get_local_id(0)*chunk+i)*2+c;\n"
"         // Multiply element from a with element from b and add to scalar total\n"
"         dot_product += aList[ix] * bList[ix];\n"
"      }\n"
"   }\n"
"   barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"/*******************************END DOT ROWS**********************************/\n"
"\n"
"\n"
"/*****************************BEGIN SUM ROWS**********************************/\n"
"/*\n"
"  To be used in the construction of variables B & C\n"
"  var sum will be passed in initialized to 0\n"
"*/\n"
"void sum_rows_individually(int chunk,  __global float* aList,  __global float* bList,\n"
"                           __global float* asum, __global float* bsum)\n"
"{\n"
"  int i,c,ix;\n"
"   // Plagerized from Josh Burns' codebase\n"
"   // These two for loops are the basic way of accessing the two 'rows'\n"
"   for (i=0;i<chunk;++i)\n"
"   {\n"
"      for (c=0;c<2;++c)\n"
"      {\n"
"         ix = (get_local_id(0)*chunk+i)*2+c;\n"
"         // Sum the two rows individually and store two seperate sums\n"
"         asum += aList[ix];\n"
"         bsum += bList[ix];\n"
"      }\n"
"   }\n"
"   barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"/*******************************END SUM ROWS**********************************/\n"
"\n"
"\n"
"/*\n"
"  To be used in the construction of variables H & I\n"
"*/\n"
"void sqaure_and_sum_row_individually(int chunk,  __global float* aList,\n"
"                                     __global float* bList, __global float* asq_sum,\n"
"                                     __global float* bsq_sum)\n"
"{\n"
"  int i,c,ix;\n"
"   // Plagerized from Josh Burns' codebase\n"
"   // These two for loops are the basic way of accessing the two 'rows'\n"
"   for (i=0;i<chunk;++i)\n"
"   {\n"
"      for (c=0;c<2;++c)\n"
"      {\n"
"         ix = (get_local_id(0)*chunk+i)*2+c;\n"
"         // Sum the square of each element in the two rows individually and\n"
"         // store two seperate sums\n"
"         asq_sum += aList[ix] * aList[ix];\n"
"         bsq_sum += bList[ix] * bList[ix];\n"
"      }\n"
"   }\n"
"   barrier(CLK_LOCAL_MEM_FENCE);\n"
"}\n"
"\n"
"\n"
"\n"
"/*\n"
"  Blindly relying that the partitioning will properly slice my\n"
"  data properly\n"
"  ***praise be to the Yoshi of BurnÃ©\n"
"*/\n"
"\n"
"__kernel void spearman(/*kern_arg0*/int size,/*kern_arg1*/ int chunk,\n"
"                       /*kern_arg2*/int minSize, /*kern_arg3 TODO: what is this?*/__global int* insts,\n"
"                       /*kern_arg4 (INPUT 1-D list)*/__global float* exprs,\n"
"                       /*kern_arg5 (OUTPUT, relationship of the two rows)*/__global float* result,\n"
"                       /*kern_arg6*/ __global float* alistF, /*kern_arg7*/__global float* blistF,\n"
"                      //  __global int* rankF, __global int* iRankF, __global long* summationF,\n"
"                       /*kern_arg8*/__global float* aTmpListF, /*kern_arg9*/__global float* bTmpListF,\n"
"                       /*kern_arg10*/__global int* aWorkF, /*kern_arg11*/__global int* bWorkF,\n"
"                       /*kern_arg12*/__global int* aPointF, /*kern_arg13*/__global int* bPointF)\n"
"{\n"
"   int i = get_group_id(0)*2;\n"
"   int j = get_group_id(0);\n"
"   int wsize = get_local_size(0)*2*chunk;\n"
"   // '1st' row initialize size\n"
"   __global float* alist = &alistF[j*wsize];\n"
"   // '2nd' row initialize size\n"
"   __global float* blist = &blistF[j*wsize];\n"
"   // not needed, used in ranking of spearman\n"
"   //__global int* rank = &rankF[j*wsize];\n"
"   //__global int* iRank = &iRankF[j*wsize];\n"
"   //__global long* summation = &summationF[j*wsize];\n"
"\n"
"   // These are to be the data prepped list of the two rows of the particular\n"
"   // kernel before bing pruned\n"
"   __global float* aTmpList = &aTmpListF[j*wsize];\n"
"   __global float* bTmpList = &bTmpListF[j*wsize];\n"
"   // The pruned  of each row (after dealing with the NANs?)\n"
"   // TODO: Verify this\n"
"   __global int* aWork = &aWorkF[j*wsize];\n"
"   __global int* bWork = &bWorkF[j*wsize];\n"
"   // TODO: What are these? (Looks like another buffer for scratch space)\n"
"   // I need them for the prune_lists ...\n"
"   __global int* aPoint = &aPointF[j*wsize];\n"
"   __global int* bPoint = &bPointF[j*wsize];\n"
"\n"
"   // what is insts? the 'row?' it looks like it\n"
"   fetch_lists(insts[i],insts[i+1],size,chunk,aTmpList,bTmpList,exprs);\n"
"   // I don't think I need prune_lists, TODO: what does it do then? \n"
"   prune_lists(chunk,aTmpList,aWork,aPoint,bTmpList,bWork,bPoint);\n"
"\n"
"\n"
"\n"
"\n"
"   // Not needed\n"
"   /*\n"
"   double_bitonic_sort_ii(chunk,aWork,aPoint,bWork,bPoint);\n"
"   construct_lists(chunk,aTmpList,alist,aPoint,bTmpList,blist,bPoint,rank,iRank);\n"
"   bitonic_sort_ff(chunk,alist,blist);\n"
"   bitonic_sort_fi(chunk,blist,rank);\n"
"   calc_ranks(chunk,summation,rank,iRank);\n"
"   accumulate(chunk,summation,iRank);\n"
"  */\n"
"\n"
"   // At this point I assume that alist and blist hold my two rows to compared\n"
"   // extracted from fetch_lists and screened NANs from prune_lists\n"
"   // here I run my sub functions\n"
"\n"
"\n"
"   if (get_local_id(0)==0)\n"
"   {\n"
"      size = iRank[0];\n"
"      if (size<minSize)\n"
"      {\n"
"         result[j] = NAN;\n"
"      }\n"
"      else\n"
"      {\n"
"         result[j] = 1.0-(6.0*(float)summation[0]/((float)size*(((float)size*(float)size)-1)));\n"
"      }\n"
"   }\n"
"}\n"
"";
